#!/usr/bin/env lua
-- Prosody IM v0.4
-- Copyright (C) 2008-2009 Matthew Wild
-- Copyright (C) 2008-2009 Waqas Hussain
-- 
-- This project is MIT/X11 licensed. Please see the
-- COPYING file in the source package for more information.
--

-- Will be modified by configure script if run --

CFG_SOURCEDIR=nil;
CFG_CONFIGDIR=os.getenv("PROSODY_CFGDIR");
CFG_PLUGINDIR=nil;
CFG_DATADIR=os.getenv("PROSODY_DATADIR");

-- -- -- -- -- -- -- ---- -- -- -- -- -- -- -- --

if CFG_SOURCEDIR then
	package.path = CFG_SOURCEDIR.."/?.lua;"..package.path
	package.cpath = CFG_SOURCEDIR.."/?.so;"..package.cpath
end

if CFG_DATADIR then
	if os.getenv("HOME") then
		CFG_DATADIR = CFG_DATADIR:gsub("^~", os.getenv("HOME"));
	end
end

-- Required to be able to find packages installed with luarocks
pcall(require, "luarocks.require")


config = require "core.configmanager"

do
	-- TODO: Check for other formats when we add support for them
	-- Use lfs? Make a new conf/ dir?
	local ok, level, err = config.load((CFG_CONFIGDIR or ".").."/prosody.cfg.lua");
	if not ok then
		print("\n");
		print("**************************");
		if level == "parser" then
			print("A problem occured while reading the config file "..(CFG_CONFIGDIR or ".").."/prosody.cfg.lua");
			local err_line, err_message = tostring(err):match("%[string .-%]:(%d*): (.*)");
			print("Error"..(err_line and (" on line "..err_line) or "")..": "..(err_message or tostring(err)));
			print("");
		elseif level == "file" then
			print("Prosody was unable to find the configuration file.");
			print("We looked for: "..(CFG_CONFIGDIR or ".").."/prosody.cfg.lua");
			print("A sample config file is included in the Prosody download called prosody.cfg.lua.dist");
			print("Copy or rename it to prosody.cfg.lua and edit as necessary.");
		end
		print("More help on configuring Prosody can be found at http://prosody.im/doc/configure");
		print("Good luck!");
		print("**************************");
		print("");
		os.exit(1);
	end
end

--- Initialize logging
require "core.loggingmanager"

--- Check runtime dependencies
require "util.dependencies"

--- Load socket framework
local server = require "net.server"



-- Maps connections to sessions --
sessions = {};
hosts = {};

--- Load and initialise core modules
require "util.import"
require "core.xmlhandlers"
require "core.rostermanager"
require "core.eventmanager"
require "core.hostmanager"
require "core.modulemanager"
require "core.usermanager"
require "core.sessionmanager"
require "core.stanza_router"

require "util.array"
require "util.iterators"
require "util.timer"

-- Commented to protect us from 
-- the second kind of people
--[[ 
pcall(require, "remdebug.engine");
if remdebug then remdebug.engine.start() end
]]

local cl = require "net.connlisteners";

require "util.stanza"
require "util.jid"

------------------------------------------------------------------------


------------- Begin code without a home ---------------------

local data_path = config.get("*", "core", "data_path") or CFG_DATADIR or "data";
require "util.datamanager".set_data_path(data_path);
require "util.datamanager".set_callback(function(username, host, datastore)
	return config.get(host, "core", "anonymous_login");
end);

----------- End of out-of-place code --------------

-- Global function to initiate prosody shutdown
function prosody_shutdown(reason)
	log("info", "Shutting down: %s", reason or "unknown reason");
	eventmanager.fire_event("server-stopping", { reason = reason });
	server.setquitting(true);
end

-- Signal to modules that we are ready to start
eventmanager.fire_event("server-starting");

-- Load SSL settings from config, and create a ctx table
local global_ssl_ctx = ssl and config.get("*", "core", "ssl");
if global_ssl_ctx then
	local default_ssl_ctx = { mode = "server", protocol = "sslv23", capath = "/etc/ssl/certs", verify = "none"; };
	setmetatable(global_ssl_ctx, { __index = default_ssl_ctx });
end

-- start listening on sockets
function net_activate_ports(option, listener, default, conntype)
	local ports = config.get("*", "core", option.."_ports") or default;
	if type(ports) == "number" then ports = {ports} end;
	
	if type(ports) ~= "table" then
		log("error", "core."..option.." is not a table");
	else
		for _, port in ipairs(ports) do
			if type(port) ~= "number" then
				log("error", "Non-numeric "..option.."_ports: "..tostring(port));
			else
				cl.start(listener, { 
					ssl = conntype ~= "tcp" and global_ssl_ctx,
					port = port,
					interface = config.get("*", "core", option.."_interface"),
					type = conntype
				});
			end
		end
	end
end

net_activate_ports("c2s", "xmppclient", {5222}, (global_ssl_ctx and "tls") or "tcp");
net_activate_ports("s2s", "xmppserver", {5269}, "tcp");
net_activate_ports("legacy_ssl", "xmppclient", {}, "ssl");

if cl.get("console") then
	cl.start("console", { interface = config.get("*", "core", "console_interface") or "127.0.0.1" })
end

-- Catch global accesses --
local locked_globals_mt = { __index = function (t, k) error("Attempt to read a non-existent global '"..k.."'", 2); end, __newindex = function (t, k, v) error("Attempt to set a global: "..tostring(k).." = "..tostring(v), 2); end }

function unlock_globals()
	setmetatable(_G, nil);
end

function lock_globals()
	setmetatable(_G, locked_globals_mt);
end

-- And lock now...
lock_globals();

eventmanager.fire_event("server-started");

-- Error handler for errors that make it this far
local function catch_uncaught_error(err)
	if err:match("%d*: interrupted!$") then
		return "quitting";
	end
	
	log("error", "Top-level error, please report:\n%s", tostring(err));
	local traceback = debug.traceback("", 2);
	if traceback then
		log("error", "%s", traceback);
	end
	
	eventmanager.fire_event("very-bad-error", "*", err, traceback);
end

while select(2, xpcall(server.loop, catch_uncaught_error)) ~= "quitting" do
	socket.sleep(0.2);
end

log("info", "Shutdown status: Cleaning up");
eventmanager.fire_event("server-cleanup");

-- Ok, we're quitting I know, but we
-- need to do some tidying before we go :)
server.setquitting(false);

log("info", "Shutdown status: Closing all active sessions");
for hostname, host in pairs(hosts) do
	log("debug", "Shutdown status: Closing client connections for %s", hostname)
	if host.sessions then
		for username, user in pairs(host.sessions) do
			for resource, session in pairs(user.sessions) do
				log("debug", "Closing connection for %s@%s/%s", username, hostname, resource);
				session:close("system-shutdown");
			end
		end
	end
	
	log("debug", "Shutdown status: Closing outgoing s2s connections from %s", hostname);
	if host.s2sout then
		for remotehost, session in pairs(host.s2sout) do
			if session.close then
				session:close("system-shutdown");
			else
				log("warn", "Unable to close outgoing s2s session to %s, no session:close()?!", remotehost);
			end
		end
	end
end

log("info", "Shutdown status: Closing all server connections");
server.closeall();

server.setquitting(true);

eventmanager.fire_event("server-stopped");
log("info", "Shutdown status: Complete!");
