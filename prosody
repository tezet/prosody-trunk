#!/usr/bin/env lua

-- Config here --

CFG_SOURCEDIR=nil;
CFG_CONFIGDIR=nil;
CFG_PLUGINDIR=nil;

-- -- -- -- -- --

if CFG_SOURCEDIR then
	if os.getenv("HOME") then
		CFG_SOURCEDIR = CFG_SOURCEDIR:gsub("^~", os.getenv("HOME"));
	end
	package.path = CFG_SOURCEDIR.."/?.lua;"..package.path
	package.cpath = CFG_SOURCEDIR.."/?.so;"..package.cpath
end

if CFG_CONFIGDIR then
	if os.getenv("HOME") then
		CFG_CONFIGDIR = CFG_CONFIGDIR:gsub("^~", os.getenv("HOME"));
	end
end	

if CFG_PLUGINDIR then
	if os.getenv("HOME") then
		CFG_PLUGINDIR = CFG_PLUGINDIR:gsub("^~", os.getenv("HOME"));
	end
end	

-- Required to be able to find packages installed with luarocks
pcall(require, "luarocks.require")


config = require "core.configmanager"
log = require "util.logger".init("general");

do
	-- TODO: Check for other formats when we add support for them
	-- Use lfs? Make a new conf/ dir?
	local ok, err = config.load((CFG_CONFIGDIR or ".").."/prosody.cfg.lua");
	if not ok then
		log("error", "Couldn't load config file: %s", err);
		log("info", "Falling back to old config file format...")
		ok, err = pcall(dofile, "lxmppd.cfg");
		if not ok then
			log("error", "Old config format loading failed too: %s", err);
		else
			for _, host in ipairs(_G.config.hosts) do
				config.set(host, "core", "defined", true);
			end
			
			config.set("*", "core", "modules_enabled", _G.config.modules);
			config.set("*", "core", "ssl", _G.config.ssl_ctx);
		end
	end
end

local data_path = config.get("*", "core", "data_path") or "data";
local path_separator = "/"; if os.getenv("WINDIR") then path_separator = "\\" end
local _mkdir = {}
function mkdir(path)
	path = path:gsub("/", path_separator);
	--print("mkdir",path);
	local x = io.popen("mkdir "..path.." 2>&1"):read("*a");
end
function encode(s) return s and (s:gsub("%W", function (c) return string.format("%%%x", c:byte()); end)); end
function mkdirs(host)
	if not _mkdir[host] then
		local host_dir = string.format("%s/%s", data_path, encode(host));
		mkdir(host_dir);
		mkdir(host_dir.."/accounts");
		mkdir(host_dir.."/vcard");
		mkdir(host_dir.."/roster");
		mkdir(host_dir.."/private");
		mkdir(host_dir.."/offline");
		_mkdir[host] = true;
	end
end
mkdir(data_path);

require "util.datamanager".set_data_path(data_path);

local server = require "net.server"

require "util.dependencies"

-- Maps connections to sessions --
sessions = {};
hosts = {};

local defined_hosts = config.getconfig();

for host, host_config in pairs(defined_hosts) do
	if host ~= "*" and (host_config.core.enabled == nil or host_config.core.enabled) then
		hosts[host] = {type = "local", connected = true, sessions = {}, host = host, s2sout = {} };
		mkdirs(host);
	end
end

-- Load and initialise core modules --

require "util.import"
require "core.xmlhandlers"
require "core.rostermanager"
require "core.offlinemessage"
require "core.modulemanager"
require "core.usermanager"
require "core.sessionmanager"
require "core.stanza_router"

--[[
pcall(require, "remdebug.engine");
if remdebug then remdebug.engine.start() end
]]

local start = require "net.connlisteners".start;
require "util.stanza"
require "util.jid"

------------------------------------------------------------------------

-- Initialise modules

for host in pairs(hosts) do
	if host ~= "*" then
		local modules_enabled = config.get(host, "core", "modules_enabled");
		if modules_enabled then
			for _, module in pairs(modules_enabled) do
				modulemanager.load(host, module);
			end
		end
	end
end

-- setup error handling
setmetatable(_G, { __index = function (t, k) print("WARNING: ATTEMPT TO READ A NIL GLOBAL!!!", k); error("Attempt to read a non-existent global. Naughty boy.", 2); end, __newindex = function (t, k, v) print("ATTEMPT TO SET A GLOBAL!!!!", tostring(k).." = "..tostring(v)); error("Attempt to set a global. Naughty boy.", 2); end }) --]][][[]][];

local protected_handler = function (conn, data, err) local success, ret = pcall(handler, conn, data, err); if not success then print("ERROR on "..tostring(conn)..": "..ret); conn:close(); end end;
local protected_disconnect = function (conn, err) local success, ret = pcall(disconnect, conn, err); if not success then print("ERROR on "..tostring(conn).." disconnect: "..ret); conn:close(); end end;


local global_ssl_ctx = config.get("*", "core", "ssl");
if global_ssl_ctx then
	local default_ssl_ctx = { mode = "server", protocol = "sslv23", capath = "/etc/ssl/certs", verify = "none"; };
	setmetatable(global_ssl_ctx, { __index = default_ssl_ctx });
end

-- start listening on sockets
start("xmppclient", { ssl = global_ssl_ctx })
start("xmppserver", { ssl = global_ssl_ctx })

if config.get("*", "core", "console_enabled") then
	start("console")
end

modulemanager.fire_event("server-started");

server.loop();
